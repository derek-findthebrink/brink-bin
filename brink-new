#!/usr/bin/env coffee

# Generated by brink 0.1.0

# requires
# --------------------
program = require "commander"
fs = require "fs-extra"
_ = require "lodash"
nodepath = require "path"
async = require "async"

traverse = require "./modules/traverse"
done = require "./modules/done"

# logic
# -----------------------

program
	.command("project <name>")
	.option("-o, --out <dir>", "output to directory <dir>, defaults to process.cwd()")
	.action (name, options)->
		opt = parseOptions(options)
		opt.name = name
		return createProject(opt)

parseOptions = (options)->
	# list and parse each option here
	out = options.out || process.cwd()
	opts = {}
	opts.out = out
	return opts

checkDir = (opts, path, file, pckg, brink, cb)->
	out = opts.out
	dir = nodepath.join path, out
	fs.stat(dir, (err, stat)->
		if stat
			# add more details here for how to solve error
			e = new Error("Already exists!")
			return cb(e)
		if err
			# console.log err:err
			# good to go!
			if err.code == "ENOENT"
				conf = {}
				conf.package = pckg
				conf.brink = brink
				return cb(null, conf)
		e = new Error("Unable to parse..")
		return cb(e)
		)

createScaffold = (opts, config, cb)->
	# use brink to generate scaffold
	brink = config.brink
	root = nodepath.join process.cwd(), brink.root

	scaffold = brink.scaffold
	# create all directories required
	# <br /> holder for all
	dirs = []
	files = []
	addDir = (obj, c)->
		root = obj.root
		i = obj.tree
		_.forOwn i, (val, key)->
			if key == "files"
				_.map val, (x)->
					f = nodepath.join root, x
					return files.push(f)
				return

			newRoot = root + "/" + key
			if  _.isObject val
				queue.push({tree: val, root:newRoot})
			else
				dirs.push(newRoot)

		return c(null)
	queue = async.queue(addDir, 1)
	# callback
	queue.drain = ->
		console.log dirs:dirs
		console.log files:files
		return cb(null, dirs, files)
	# initiate
	queue.push({tree:scaffold, root: root})


createDirs = (dirs, files, cb)->
	_createDirs = (x)->
		dir = nodepath.join x
		return fs.ensureDir(dir, cb)

	if _.isArray dirs
		async.map dirs, _createDirs, (err)->
			return cb(err)
	if _.isString dirs
		return fs.ensureDir(dirs, cb)

createFiles = (cb)->
	return cb(null)

createProject = (opts)->
	async.waterfall([
		traverse
		async.apply checkDir, opts
		async.apply createScaffold, opts
		# createDirs
		# createFiles
		], done)



program.parse(process.argv)